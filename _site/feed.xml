<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-07T14:32:48+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">diary</title><subtitle>devlogs</subtitle><author><name>laegel</name></author><entry><title type="html">[JVM] JVM 총정리 - 런타임 영역(2)</title><link href="http://localhost:4000/jvm/ch1/" rel="alternate" type="text/html" title="[JVM] JVM 총정리 - 런타임 영역(2)" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/jvm/ch1</id><content type="html" xml:base="http://localhost:4000/jvm/ch1/"><![CDATA[<p><em>런타임 영역</em> 은 JVM 이 런타임 환경에서 자바 프로그램을 수행할 때 OS 로부터 할당받는 메모리 영역이다. 이 메모리 영역은 논리적으로 다음과 같이 5가지 영역으로 구분한다.</p>

<ul>
  <li>Method Area</li>
  <li>Heap Area</li>
  <li>PC Register</li>
  <li>Native Method Stack</li>
  <li>JVM Stack</li>
</ul>

<hr />

<h2 id="method-area">Method Area</h2>
<p><em>Method Area</em> 는 JVM 벤더마다 다르게 구현되어 있다. 그러나 거의 모든 운영체제에서는 Hotspot 이라는 벤더를 사용하므로 이것을 기준으로 설명할 것이다.</p>

<p>Hotspot JVM 벤더는 JDK 8 버전 기준으로 메모리 영역에 변화가 생겼다. 크게는 기존 Perm 영역(Perm Generation) 이 사라지고 Metaspace 영역이 등장하게 된 것인데, Method Area 가 JVM 에서 어떤 역할을 하는지, JDK 8 버전이 되며 어떤 변화가 생겼는지 알아보자.</p>

<h3 id="perm-영역의-역할">Perm 영역의 역할</h3>
<p><img src="../../assets/img/java/jvm04.png" /></p>

<p><em>Perm 영역</em> 은 런타임 환경에서 클래스 로더를 통해 로드된 클래스와 메서드의 메타 데이터가 저정되는 영역이다. 전역 변수나 static 변수 또한 이 영역에 저장되고 프로그램이 종료될 때까지 남아있게 된다. 또한 해당 정보에 대한 요청이 오면 실제 
물리 메모리 주소로 변환할 수 있게 하는 영역이다.</p>

<p>이 영역에 저장되는 데이터르 좀 더 세부화하자면 다음과 같다.</p>

<h4 id="1-type-information">1. Type Information</h4>
<ul>
  <li>클래스와 인터페이스 정보를 뜻한다. 다음과 같은 분류에 따라 정보를 저장한다.
    <ul>
      <li>Type 명: Package name + Class name 형식</li>
      <li>Type 종류: Type 이 Class 인지 Interface 인지에 대한 정보</li>
      <li>Type 의 제어자: 접근 제어자, 제어자 에 대한 정보</li>
      <li>연관된 Interface 정보: 사용된 Interface 의 정보</li>
    </ul>
  </li>
</ul>

<h4 id="2-runtime-constant-pool">2. Runtime Constant Pool</h4>
<ul>
  <li>Type 의 상수 정보를 저장하는 영역이다. 각 상수는 인덱스를 통해 접근이 가능하다. 또한 method, field, type 으로 접근하기 위한 reference 정보가 저장되기 때문에 독자적인 중요성이 있다.</li>
</ul>

<h4 id="3-field-information">3. Field Information</h4>
<ul>
  <li>인스턴스 변수의 정보를 저장한다.</li>
</ul>

<h4 id="4-method-information">4. Method Information</h4>
<ul>
  <li>메서드의 모든 정보를 저장한다.</li>
</ul>

<h4 id="5-class-variable">5. Class Variable</h4>
<ul>
  <li>static 키워드로 선언된 변수가 저장된다.</li>
</ul>

<h3 id="perm-영역의-한계">Perm 영역의 한계</h3>
<p><em>Perm 영역</em> 은 논리적으로 Method Area 에 속해있지만, 사실 Perm 영역은 Heap Area 내에서 분리된 특수한 공간에 위치한다. 때문에 처음 JVM 에 의해 메모리가 할당이 될 때 영역의 크기가 제한적으로 할당될 수밖에 없고, 이로 인해 런타임 환경에서 
OutOfMemory 에러 유발 문제와 GC 를 수시로 해줘야 하는 메모리 누수가 유발된다. 이러한 문제들로 인해 JDK 버전이 8로 올라감에 따라 Perm 영역이 제거되고 Metasapce 영역이 새롭게 등장하게 된다.</p>

<h4 id="metaspace-영역의-등장">Metaspace 영역의 등장</h4>
<p>Perm 영역과 비교해 <em>Metaspace 영역</em>의 가장 중요한 차이점은 <em>메모리 할당을 처리하는 방법</em>이 달라졌다는 것이다.<br />
<em>Metaspace 영역</em> 은 Native Memory 영역으로 전환되었다. 또한 OS 에 의해 메모리 할당 공간이 자동으로 조절되게끔 바뀌면서 이론상 아키텍쳐가 지원하는 메모리 크기까지 확장할 수 있게 되었다. 따라서 Perm 영역과 비교해 메모리 공간 확보 기능이 향상되었고 
보다 유연하고 안정적인 메모리 사용을 제공할 수 있게 되었다. 또한 Method Area 이면서 애매하게 Heap Area 에 속해있던 과거와 달리 명확하게 Heap Area 영역과 독립된 개념으로 존재할 수 있게 되었다.</p>

<p>다음으로 중요한 변경점은 <em>string 과 static object 의 저장 방법</em> 이다.
먼저, string 값 저장 방식의 변경은 다음과 같다.<br />
JDK 8 버전 이하에서 문자열 리터럴 방식을 통해 생성하는 string 값은 Runtime Constant Pool 에 저장되었다. 그러나 JDK 8 버전 이후 Runtime Constant Pool 에서 String Constant Pool 이라는 개념이 별도로 분리되어 Heap Area 에 저장되게 변경되었다.
이로 인해 string 리터럴 값이 GC 의 대상이 될 수 있어 메모리 관리가 좀 더 효율적으로 이루어 질 수 있게 되었다.</p>

<p>static object 도 마찬가지로 비슷하게 변경되었다.<br />
기존 Perm 영역에서는 static object 가 Perm 영역에 저장되어 GC 의 대상이 되지 않았지만, JDK 8 버전 이후 Heap Area 에 저장되도록 변경되었고, reference 값만 Metaspace 에서 관리하게 함으로써 사용되지 않는 static object 는 GC 의 대상이 될 수 있게 되었다.</p>

<h2 id="heap-area">Heap Area</h2>
<p><em>Heap Area</em> 는 Object 클래스를 상속받는 모든 객체들(클래스 인스턴스)과 해당 인스턴스 변수들을 담는 공간이다. 이곳에서는 실제 데이터를 가진 인스턴스와 배열 뿐만 아니라 문자열에 대한 정보를 가진 String Constant Pool(JDK 8 이후) 등이 저장된다.</p>

<p>이 영역은 JVM 당 하나만 생성이 되며, 해당 영역이 가진 데이터는 모든 JVM Stack 영역에서 참조되어 thread 간 공유되기 때문에 같은 애플리케이션을 사용하는 thread 사이에서 인스턴스를 공유하는 경우 동기화 문제가 수반될 수 있다. 또한 참조되지 않는 
인스턴스와 배열에 대한 정보를 얻을 수 있기 때문에 GC 의 주 대상이 되는 영역이다.</p>

<h3 id="hotspot-jvm-의-heap-area-구조">Hotspot JVM 의 Heap Area 구조</h3>
<p>앞서 설명한 이유와 마찬가지로 Hotspot 모델을 기반으로 한 HEAP Area 영역에 대해 살펴보자.
<img src="../../assets/img/java/jvm05.png" /></p>

<p>Hotspot JVM 은 크게 Yong 영역과 Old 영역으로 나뉘어져 있다.</p>

<p><em>Yong 영역</em>은 객체가 새로 생성되면 할당되는 영역으로, 상태에 따라 Eden, Servior0, Servior1 영역으로 구분되어 저장된다.<br />
대부분의 객체가 금방 Unreachable 상태가 되기 때문에 (어떠한 경우에도 절대 실행되지 않는 상태), 많은 객체가 이 영역에서 생성되었다가 사라진다. 이 영역에서 발생하는 GC 를 Minor GC 라고 부른다.</p>

<p><em>Old 영역</em>은 Yong 영역에서 Reachable 상태를 유지하며 살아남은 객체가 복사되는 영역이다. 계속해서 사용되는 객체들이 저장되는 공간이기 때문에 Yong 영역보다 크게 할당되며 GC 작업 시간이 Minor GC 보다 훨씬 오래 걸린다.<br />
이 영역에서 일어나는 GC를 Major GC 라 부른다.</p>

<h2 id="pc-register">PC Register</h2>
<p><em>PC Register</em> 는 쓰레드가 현재 실행중인 메서드의 명령을 담고 있는 JVM 명령어 주소를 저장한다.</p>

<p>명령어가 자바 메서드를 수행하고 있다면 JVM 명령어의 주소를 저장하지만, 만약 다른 언어의 메서들를 수행한다면 UNDEFINED 상태가 되고, 다른 언어의 메서드는 뒤에 설명할 Native Method Stack Srea 에서 수행하게 된다.</p>

<h2 id="jvm-stack">JVM Stack</h2>
<p><em>JVM Stack</em> 은 메서드를 호출할 때마다 frame 이라는 단위의 정보를 push(추가) 하고 메서드가 종료되면 해당 frame을 pop(제거) 하는 동작을 수행한다. 이런 특징으로 자바에서 변수는 선언된 블록 안에서만 유효하고, 블록을 벗어나면 스택에서 제거되어 알 수 없게 된다.</p>

<p>frame 은 다음 3가지로 구성된다.</p>
<ul>
  <li>Local Variable: 메서드의 지역 변수들을 갖는다.</li>
  <li>Operand Stack: 메서드 내 계산을 위한 작업 공간이다. 바이트 코드 명령문들이 들어있는 공간이라고 할 수 있다.</li>
  <li>Constant Pool Reference: Constant Pool 참조를 위한 공간이다.</li>
</ul>

<h2 id="native-method-stack">Native Method Stack</h2>
<p>프로그램을 실행하다 보면 경우에 따라서는 순수하게 JAVA로 구성된 코드만을 사용할 수 없는 시스템의 자원이나 API가 존재한다. 이러한 다른 프로그래밍 언어로 작성된 메서드들을 native method 라고 하는데, Native Method Stack 은 이런 native method 
들을 다루는 영역이다.</p>

<p>기본 동작 과정은 다음과 같다.
<img src="../../assets/img/java/jvm06.png" /></p>

<p>일반적인 메서드가 실행될 때 해당 frame 들이 JVM Stack 에 쌓이며 실행이 되다가 native method 를 만나면 해당 메서드를 Native Method Stack Area 에 쌓고 수행이 끝난 뒤 다시 JVM Stack 으로 돌아오게 된다. 이 때, native method 를 호출한 
stack frame 으로 돌아가는 것이 아닌 새로운 stack frame 을 생성하여 다시 작업을 수행하게 된다. 그렇기 때문에 native code 로 되어있는 함수의 호출을 자바 프로그램 내에서 직접 수행할 수 있고, 그 결과를 받아올 수 있는 것이다.</p>

<p>결과적으로 JVM 은 Native Stack Frame 영역을 통해 JNI(Java Native Interface) 방식을 지원한다고 할 수 있겠다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>여기서 JNI(Java Native Interface) 란 다른 언어로 작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크를 말한다.
</code></pre></div></div>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>laegel</name></author><category term="JVM" /><category term="Java" /><category term="JVM" /><summary type="html"><![CDATA[런타임 영역 은 JVM 이 런타임 환경에서 자바 프로그램을 수행할 때 OS 로부터 할당받는 메모리 영역이다. 이 메모리 영역은 논리적으로 다음과 같이 5가지 영역으로 구분한다.]]></summary></entry><entry><title type="html">[JVM] JVM 총정리 - 클래스 로더(1)</title><link href="http://localhost:4000/jvm/ch0/" rel="alternate" type="text/html" title="[JVM] JVM 총정리 - 클래스 로더(1)" /><published>2023-07-31T00:00:00+09:00</published><updated>2023-07-31T00:00:00+09:00</updated><id>http://localhost:4000/jvm/ch0</id><content type="html" xml:base="http://localhost:4000/jvm/ch0/"><![CDATA[<p><em>JVM</em> 은 사용자 컴퓨터 운영체제에 맞는 JRE 에 포함되어 있는 소프트웨어로, 바이트 코드로 변환된 자바 코드를 실행시켜주는 역할을 한다. 또한 자바 프로그램을 실행함에 있어 .class 파일에 대한 유효성 검사와 메모리 관리, GC 등의 작업을 수행하기 때문에 매우 중요한 소프트웨어라고 할 수 있다.</p>

<p>먼저 JVM 내부 구조를 살펴보자.</p>

<h2 id="1-jvm-내부구조">1. JVM 내부구조</h2>

<p><em>JVM</em> 은 크게 다음과 같이 이루어져 있다.</p>

<ul>
  <li>클래스 로더 (class loader)</li>
  <li>실행 엔진 (execution engine)
    <ul>
      <li>인터프리터 (interpreter)</li>
      <li>JIT Compiler</li>
      <li>가비지 콜렉터 (garbage collector)</li>
    </ul>
  </li>
  <li>런타임 영역 (runtime data area)</li>
</ul>

<p>이것을 그림으로 표현하면 다음과 같다.<br />
<img src="../../assets/img/java/jvm01.png" /></p>

<h2 id="2-클래스-로더-class-loader">2. 클래스 로더 (Class Loader)</h2>

<p>클래스 로더는 런타임 환경에서 동적으로 .class 파일을 읽어 런타임 영역 (Runtime Data Area) 에 적재한다. 뿐만 아니라 클래스 파일이 유효한지 검증하고, 필드 및 메서드를 초기화 하는 역할을 하는 매우 중요한 부분이다.
클래스 로더는 위 역할을 수행하기 위해 크게 세 가지 과정을 거쳐 동작하는데 그림으로 표현하자면 다음과 같다.
 <img src="../../assets/img/java/jvm02.png" /></p>

<h3 id="2-1-로딩-loading">2-1. 로딩 (Loading)</h3>
<p>로딩 단계는 JVM 이 런타임 환경에서 필요한 클래스 파일을 찾아 탑재하는 과정을 말한다. 이 동작은 각각의 클래스 파일들이 JDK 에 의해 기본적으로 제공받는 클래스 파일인지 혹은 개발자가 정의한 클래스 파일인지와 같은 기준에 의해
세 가지 Class Loader 로 나뉘어 실행된다.<br />
 <img src="../../assets/img/java/jvm03.png" /></p>

<h4 id="2-1-1-bootstrap-class-loader">2-1-1. Bootstrap Class Loader</h4>
<p>JVM 이 시작되고 가장 최초로 실행되는 최상위 Class Loader 이다. <em>Bootstrap Class Loader</em> 는 JDK 8 기준으로 jre/lib/rt.jar 파일에 위치한 자바 런타임 코어 클래스들을 로드한다. 런타임 코어 클래스들에는 java.lang, java.util 등과 같은
필수 패키지들이 들어있다.<br />
 <em>Bootstrap Class Loader</em> 는 가장 상위의 Class Loader 이므로 다른 Clas Loader 와 다르게 탑재되는 운영체제에 맞게 Native Code 로 쓰여있다.</p>

<h4 id="2-1-2-extensions-class-loader">2-1-2. Extensions Class Loader</h4>
<p><em>Bootstrap Class Loader</em> 다음으로 우선순위를 가지는 Class Loader 이다. 주로 jre/lib/ext 디렉토리나 java.ext.dirs 환경 변수로 지정한 디렉토리 안에 있는 클래스 파일들을 로딩하며 JDK 확장 라이브러리들을 다룬다.</p>

<h4 id="2-1-3-application-class-loader">2-1-3. Application Class Loader</h4>
<p>자바 프로그램 실행 시 classpath 에 있는 클래스 혹은 jar 에 속한 클래스들을 로드한다. 주로 개발자들이 작성한 자바 코드 클래스 파일들을 탑재하는 역할을 하고 있다.</p>

<blockquote>
  <h3 id="jdk-9-버전-이후-변경점">JDK 9 버전 이후 변경점</h3>
  <p>JDK 9 버전 이후 JDK 에 module 개념이 새롭게 탑재되며 기존 jre, ext 디렉토리 등이 삭제되고 해당 기능들은 작은 단위의 모듈로 분리되게 되었다. 이로 인해 자바 프로그램이 전체 JDK 를 실행하지 않아 더 효율적인 포맷으로 진화하였다.
 또한 이러한 변경점으로 인해 주요 Class Loader 들의 주요 기능이나 명칭도 변경되었다. 아래는 JDK 9 버전 이후의 변경점이다.</p>

  <h4 id="1-bootstrap-class-loader">1. Bootstrap Class Loader</h4>
  <p>기존에는 모든 Java SE 클래스들을 로드할 수 있었지만, rt.jar 가 모듈화되어 작은 단위로 나뉘어지면서 java.base 같은 중요한 모듈의 클래스 로딩만 다루게 역할이 축소되었다.</p>

  <h4 id="2-platform-class-loader">2. Platform Class Loader</h4>
  <p>Extensions Class Loader 에서 명칭이 변경되었다. Java SE 플랫폼에 있는 모든 클래스들에 대해 로더 역할을 수행할 수 있게 확장되었으며 Java SE 플랫폼에 속해있지 않은 표준화된 JCP(Java Community Process) 클래스에 대해서도 로더 역할을 할 수 있게 변경되었다.</p>

  <h4 id="3-system-class-loader">3. System Class Loader</h4>
  <p>Application Class Loader 에서 명칭이 변경되었다. Java SE 나 모듈이 아닌 모듈들에 대해서도 default 로더 역할을 수행할 수 있게 변경되었다.</p>

  <p>자세한 변경사항은 <a href="https://homoefficio.github.io/2018/10/14/Java-URLClassLoader%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%94%A9/">다음</a></p>
</blockquote>

<h3 id="loading-동작-방식">Loading 동작 방식</h3>
<p>Class Loader 는 다음과 같은 위임 방식으로 클래스들을 로딩한다.<br />
<em>System Class Loader -&gt; Platform Class Loader -&gt; Bootstrap Class Loader</em></p>

<p>요청한 클래스가 위와 같은 위임 과정을 거쳐 Class Loader 에 의해 로드가 되지 않는다면 java.lang.ClassNotFoundException 이 발생하겟지만, 로드에 성공한다면 내용에 맞는 바이너리 데이터를 생성한 뒤 메모리의 Method Area 에 저장한다. 그 후 Class<객체이름> 형태의 해당 클래스
타입의 class 객체를 생성해 Heap 영역에 저정하게 된다.</객체이름></p>

<h3 id="2-2-링킹-linking">2-2. 링킹 (Linking)</h3>
<p>이 단계에서는 로드된 클래스나 인터페이스, 필요한 경우 요소 타입을 검증하고 사용할 수 있게 준비하는 과정을 포함한다. 이 작업은 Verification, Preparation, Resolution 이라는 세 단계로 이루어진다.</p>

<h4 id="1-검증-verification">1) 검증 (Verification)</h4>
<p>클래스 로더가 .class 파일의 바이트코드를 자바 언어 명세서 (Java Language Specification) 에 따라서 코드를 제대로 작성했는지, JVM 규격에 맞게 검증된 컴파일러에서 .class 파일이 생성되었는지 등을 확인하여 .class 파일의 정확성을 보장해준다.<br />
 내부적으로 바이트 코드 검증기가 이 과정을 담당하며 만약 검증이 실패한다면 java.lang.VerifyError 를 발생시킨다. 다만, Bootstrap ClassLoader 에 의해 로드된 클래스들은 신뢰성이 높은 자원에서 로드된 클래스들이기 때문에 해당 Verification 단계를 거치지 않는다.</p>

<p>이러한 Verification 은 사실 컴파일 단계에서도 수행이 된다. 하지만 JVM 에서 다시 한 번 이 검증을 거치게 되면서 클래스 파일의 악의적인 혹은 유효하지 않는 변경을 미연에 방지할 수 있게 된다.</p>

<h4 id="2-준비-preparation">2) 준비 (Preparation)</h4>
<p>이 단계에서는 static fields 에 대한 메모리를 할당한다. 다만, 주어진 값으로 초기화는 나중에 진행될 Initializa 단계에서 실행되면 이 단계에서는 타입의 기본 값으로 초기화가 진행된다. 때문에 이 단계에서 클래스 파일의 코드를 작동시키진 않는다.<br />
만약, 이 단계에서 할당할 메모리 공간이 부족하다면 OutOfMemoryError 가 발생한다.</p>

<h4 id="3-해석-resolutions">3) 해석 (Resolutions)</h4>
<p>해석 단계는 해당 클래스의 참조된 클래스들을 로드하는 과정이다. 이 과정은 Linking 의 Preparation 단계에서 수행될 수도 있고, Initialization 단계 이후 수행될 수도 있다.</p>

<p>Linking 작업은 필요할 때마다 동적으로 이루어지기 때문에 Dynamic Linking 이라는 표현을 사용하기도 한다.<br />
사실 .class 파일은 실행 시 Link 될 수 있도록 Symbolic Reference 만을 가지고 있다. 이 Symblic Reference 는 해석 단계에서 Method Area 의 Runtime Constant Pool 을 거쳐 실제로 존재하는 물리적인 주소로 대체되게 된다. 이러한 과정의 Dynamic Linking 덕분에 class 파일의
크기를 작게 유지할 수 있어 메모리 요구사항이 훨씬 적어지게 된다.</p>

<h3 id="2-3-초기화-initialization">2-3. 초기화 (Initialization)</h3>

<p>이 과정에서는 로드된 각 클래스나 인터페이스의 코드를 읽고 초기화 로직이 실행되게 된다. static 변수와 메서드가 코드에 명시된 원래 값으로 할당이 되고, 정적 초기화 블록이 실행되게 된다. 이 작업은 클래스의 위에서 아래로, 클래스 계층 구조에서 부모부터 자식까지 한 줄씩 진행된다.</p>

<p>초기화 과정까지 거쳐 클래스 탑재 과정이 끝나게 된다면 본격적으로 JVM 에서 클래스 파일을 구동시킬 준비가 끝나게 된다.</p>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>laegel</name></author><category term="JVM" /><category term="Java" /><category term="JVM" /><summary type="html"><![CDATA[JVM 은 사용자 컴퓨터 운영체제에 맞는 JRE 에 포함되어 있는 소프트웨어로, 바이트 코드로 변환된 자바 코드를 실행시켜주는 역할을 한다. 또한 자바 프로그램을 실행함에 있어 .class 파일에 대한 유효성 검사와 메모리 관리, GC 등의 작업을 수행하기 때문에 매우 중요한 소프트웨어라고 할 수 있다.]]></summary></entry><entry><title type="html">[Spring Security] Spring Security 란 ?</title><link href="http://localhost:4000/spring%20security/ch0/" rel="alternate" type="text/html" title="[Spring Security] Spring Security 란 ?" /><published>2023-07-23T00:00:00+09:00</published><updated>2023-07-23T00:00:00+09:00</updated><id>http://localhost:4000/spring%20security/ch0</id><content type="html" xml:base="http://localhost:4000/spring%20security/ch0/"><![CDATA[<p>이건 테스트입니다 하하하하하</p>

<p>TestTest</p>

<p><a href="#" class="btn btn--primary align-right">맨 위로 이동하기</a></p>]]></content><author><name>laegel</name></author><category term="Spring Security" /><category term="Spring Security" /><summary type="html"><![CDATA[이건 테스트입니다 하하하하하]]></summary></entry></feed>